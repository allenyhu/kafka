
/*Test for Multiple Sources at the Top Level, with no child*/
//final StreamsBuilder builder = new StreamsBuilder();
//
//        List<String> topics =  new ArrayList<>();
//        topics.add("streams-plaintext-input");
////        topics.add("TESTTOPIC1");
////        topics.add("TESTTOPIC2");
////        topics.add("TESTTOPIC3");
////        topics.add("TESTTOPIC4");
////        topics.add("TESTTOPIC5");
//
//        builder.stream(topics).to("streams-pipe-output");
//
//final KafkaStreams streams = new KafkaStreams(builder.build(), props);
//{streams-plaintext-input=0011}

/*Test for Multiple Sources at the Top Level, with single child.*/
//static void createWordCountStream(final StreamsBuilder builder) {
//        List<String> topics =  new ArrayList<>();
//        topics.add(INPUT_TOPIC);
//        topics.add("TESTTOPIC1");
//        topics.add("TESTTOPIC2");
//        topics.add("TESTTOPIC3");
//        topics.add("TESTTOPIC4");
//        topics.add("TESTTOPIC5");
//
//final KStream<String, String> source = builder.stream(topics);
//final KTable<String, Long> counts = source
//        .flatMapValues(value -> Arrays.asList(value.toLowerCase(Locale.getDefault()).split(" ")))
//        .groupBy((key, value) -> value)
//        .count();
//
//        counts.toStream().to(OUTPUT_TOPIC, Produced.with(Serdes.String(), Serdes.Long()));
//        }
//{streams-plaintext-input=0000000011111111, TESTTOPIC5=0000000011111111, TESTTOPIC2=0000000011111111, TESTTOPIC1=0000000011111111, TESTTOPIC4=0000000011111111, TESTTOPIC3=0000000011111111}

/*Test of Multiple Sinks with Single Source, has a dangling processor*/
//static void createWordCountStream(final StreamsBuilder builder) {
//
//
//        List<String> topics =  new ArrayList<>();
//        topics.add(INPUT_TOPIC);
//
//final KStream<String, String> source = builder.stream(topics);
//final KTable<String, Long> counts = source
//        .flatMapValues(value -> Arrays.asList(value.toLowerCase(Locale.getDefault()).split(" ")))
//        .groupBy((key, value) -> value)
//        .count();//
//
//        // need to override value serde to Long type
//
//
//        counts.toStream().to(OUTPUT_TOPIC, Produced.with(Serdes.String(), Serdes.Long()));
//        counts.filter((key, value) -> value > 1);
//        counts.toStream().to("TESTSINK", Produced.with(Serdes.String(), Serdes.Long()));
//
//        }
//{streams-plaintext-input=0000000011010011111111}


/*Test With Multiple Sources and Sinks, has dangling processor*/
//static void createWordCountStream(final StreamsBuilder builder) {
//        List<String> topics =  new ArrayList<>();
//        topics.add(INPUT_TOPIC);
//        topics.add("TESTTOPIC1");
//        topics.add("TESTTOPIC2");
//        topics.add("TESTTOPIC3");
//        topics.add("TESTTOPIC4");
//        topics.add("TESTTOPIC5");
//
//final KStream<String, String> source = builder.stream(topics);
//final KTable<String, Long> counts = source
//        .flatMapValues(value -> Arrays.asList(value.toLowerCase(Locale.getDefault()).split(" ")))
//        .groupBy((key, value) -> value)
//        .count();
//
//        counts.toStream().to(OUTPUT_TOPIC, Produced.with(Serdes.String(), Serdes.Long()));
//        counts.filter((key, value) -> value > 1);
//        counts.toStream().to("TESTSINK", Produced.with(Serdes.String(), Serdes.Long()));
//        }
//{streams-plaintext-input=0000000011010011111111, TESTTOPIC5=0000000011010011111111, TESTTOPIC2=0000000011010011111111, TESTTOPIC1=0000000011010011111111, TESTTOPIC4=0000000011010011111111, TESTTOPIC3=0000000011010011111111}

/*Test With Multiple Sinks that one that has child and one that does not*/
//static void createWordCountStream(final StreamsBuilder builder) {
//        List<String> topics =  new ArrayList<>();
//        topics.add(INPUT_TOPIC);
//
//final KStream<String, String> source = builder.stream(topics);
//final KTable<String, Long> counts = source
//        .flatMapValues(value -> Arrays.asList(value.toLowerCase(Locale.getDefault()).split(" ")))
//        .groupBy((key, value) -> value)
//        .count();
//
//        source.filter((key, value) -> value.length() > 1).to(OUTPUT_TOPIC);
//
//
//        counts.toStream().to(OUTPUT_TOPIC, Produced.with(Serdes.String(), Serdes.Long()));
//        }
//{streams-plaintext-input=00000000111111100111}

/*Attempted test at diamond, diamond cannot be formed, but two sinks with the same topic were created*/
//static void createWordCountStream(final StreamsBuilder builder) {
//        List<String> topics =  new ArrayList<>();
//        topics.add(INPUT_TOPIC);
//
//final KStream<String, String> source = builder.stream(topics);
//final KTable<String, Long> counts = source
//        .flatMapValues(value -> Arrays.asList(value.toLowerCase(Locale.getDefault()).split(" ")))
//        .groupBy((key, value) -> value)
//        .count();
//
//        counts.filter((key, value) -> value > 1).toStream().to(OUTPUT_TOPIC);
//
//
//        counts.toStream().to(OUTPUT_TOPIC, Produced.with(Serdes.String(), Serdes.Long()));
//        }
//{streams-plaintext-input=0000000001110011111111}

/*Tested two seperate topologies that have the exact same structure*/
//static void createWordCountStream(final StreamsBuilder builder) {
//        List<String> topics =  new ArrayList<>();
//        topics.add(INPUT_TOPIC);
//
//final KStream<String, String> source = builder.stream(topics);
//final KTable<String, Long> counts = source
//        .flatMapValues(value -> Arrays.asList(value.toLowerCase(Locale.getDefault()).split(" ")))
//        .groupBy((key, value) -> value)
//        .count();
//
//        counts.filter((key, value) -> value > 1).toStream().to(OUTPUT_TOPIC);
//
//        counts.toStream().to(OUTPUT_TOPIC, Produced.with(Serdes.String(), Serdes.Long()));
//        }
//
//public static void main(final String[] args) {
//final Properties props = getStreamsConfig();
//
//final StreamsBuilder builder = new StreamsBuilder();
//        createWordCountStream(builder);
//
//        Topology t = builder.build();
//
//final StreamsBuilder testBuild = new StreamsBuilder();
//        createWordCountStream(testBuild);
//
//        Topology tt = testBuild.build();
//
//        testBuild.stream("TESTTOPIC").to("TESTSINK");
//final KafkaStreams streams = new KafkaStreams(t, props);
//final KafkaStreams testStream = new KafkaStreams(tt, props);
//final CountDownLatch latch = new CountDownLatch(1);
//
//        System.out.println(t.describe());
//        System.out.println(t.serialize().toString());
////
//        System.out.println(tt.describe());
//        System.out.println(tt.serialize().toString());
//{streams-plaintext-input=0000000001110011111111}
//{streams-plaintext-input=0000000001110011111111}

/*Isomorphic test for two really different graphs*/
//public static void main(final String[] args) {
//final Properties props = getStreamsConfig();
//
//final StreamsBuilder builder = new StreamsBuilder();
//        createWordCountStream(builder);
//        Topology t = builder.build();
//final KafkaStreams streams = new KafkaStreams(t, props);
//
//
//final Properties props2 = new Properties();
//        props2.put(StreamsConfig.APPLICATION_ID_CONFIG, "streams-pipe");
//        props2.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
//        props2.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());
//        props2.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());
//
//        // setting offset reset to earliest so that we can re-run the demo code with the same pre-loaded data
//        props2.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
//
//final StreamsBuilder builder2 = new StreamsBuilder();
//
//        List<String> topics =  new ArrayList<>();
//        topics.add("streams-plaintext-input");
//
//        builder2.stream(topics).to("streams-pipe-output");
//        Topology pipeTest = builder2.build();
//final KafkaStreams streams2 = new KafkaStreams(pipeTest, props2);
//
////        final StreamsBuilder testBuild = new StreamsBuilder();
////        createWordCountStream(testBuild);
////        Topology tt = testBuild.build();
////        testBuild.stream("TESTTOPIC").to("TESTSINK");
////        final KafkaStreams testStream = new KafkaStreams(tt, props);
//final CountDownLatch latch = new CountDownLatch(1);
//
//        System.out.println(t.describe());
////        System.out.println(t.serialize().toString());
//
//        System.out.println(pipeTest.describe());
//
//        System.out.println(t.isIsomorphic(pipeTest));
//
////
////        System.out.println(tt.describe());
////        System.out.println(tt.serialize().toString());
//false

/*Isomorphic test for two similair graphs*/
//public static void main(final String[] args) {
//final Properties props = getStreamsConfig();
//
//final StreamsBuilder builder = new StreamsBuilder();
//        createWordCountStream(builder);
//        Topology t = builder.build();
//final KafkaStreams streams = new KafkaStreams(t, props);
//
//final StreamsBuilder builder2 = new StreamsBuilder();
//        createWordCountStream2(builder2);
//        Topology tt = builder2.build();
//final KafkaStreams stream2 = new KafkaStreams(tt, props);
//
//final CountDownLatch latch = new CountDownLatch(1);
//
//        System.out.println(t.describe());
//
//        System.out.println(tt.describe());
//
//        System.out.println(t.isIsomorphic(tt));
//false

/*Isomorphic test for two graphs with only one node difference*/
//public static void main(final String[] args) {
//final Properties props = getStreamsConfig();
//
//final StreamsBuilder builder = new StreamsBuilder();
//        createWordCountStream(builder);
//        Topology t = builder.build();
//final KafkaStreams streams = new KafkaStreams(t, props);
//
//final StreamsBuilder builder2 = new StreamsBuilder();
//        createWordCountStream2(builder2);
//        Topology tt = builder2.build();
//final KafkaStreams stream2 = new KafkaStreams(tt, props);
//
//final CountDownLatch latch = new CountDownLatch(1);
//
//        System.out.println(t.describe());
//
//        System.out.println(tt.describe());
//
//        System.out.println(t.isIsomorphic(tt));
//false